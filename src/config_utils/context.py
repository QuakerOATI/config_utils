"""Mixins and classes to support recursively-merged objects."""

from abc import ABC, abstractmethod
from typing import Any, Optional, Self


class ContextMixin(ABC):
    """Mixin for an object with insert and merge functionality.

    This is intended to be used as an interface wrapper around existing
    methods, which is justified by the fact that "merge-like" operations have
    different names for different types, complicating duck-typing in cases
    where the key operations are "merge" or "insert".  For example,
    ``dict.update()`` and ``list.extend()`` are both "merge-like"; wrapping
    ``dict`` and ``list`` in a ``ContextMixin`` allows both to be handled in
    the same manner by a container that recursively merges elements as they are
    added, which is the intended use-case.
    """

    def __init__(self, *args, **kwargs) -> None:
        # Call super() to support cooperative multi-inheritance
        super().__init__(*args, **kwargs)

    @abstractmethod
    def insert(self, item: Any, *args, **kwargs) -> None:
        """Insert an item into the context.

        Insertion should be performed without attempting to merge the inserted
        item as a subcontext.

        Varargs and varkeywords are included in the signature to indicate that
        subclasses' implementations of this method are allowed to depend on
        arbitrary subclass-specific data.  For instance, DictContext allows
        passing an optional ``key`` parameter in addition to the item being
        inserted.  Subclasses which don't require this behavior should opt out
        of it by removing the varargs and varkeywords from the signature.
        """
        ...

    @abstractmethod
    def merge(self, other: Self, *args, **kwargs) -> None:
        """Merge with another context.

        Varargs and varkeywords are included in the signature to indicate that
        subclasses' implementations of this method are allowed to depend on
        arbitrary subclass-specific data.  For instance, DictContext allows
        passing an optional ``key`` parameter in addition to the item being
        inserted.  Subclasses which don't require this behavior should opt out
        of it by removing the varargs and varkeywords from the signature.
        """
        ...

    def join(self, obj: Any, *args, **kwargs) -> None:
        """Multiple-dispatch wrapper around insert() and merge().

        Varargs and varkeywords are included in the signature to indicate that
        subclasses' implementations of this method are allowed to depend on
        arbitrary subclass-specific data.  For instance, DictContext allows
        passing an optional ``key`` parameter in addition to the item being
        inserted.  Subclasses which don't require this behavior should opt out
        of it by removing the varargs and varkeywords from the signature.
        """
        if isinstance(obj, self.__class__):
            self.merge(obj, *args, **kwargs)
        else:
            self.insert(obj, *args, **kwargs)


class ListContext(list, ContextMixin):
    """A wrapper around the standard Python list supporting recursive merging."""

    def insert(self, item: Any) -> None:
        """A wrapper around list.append."""
        self.append(item)

    def merge(self, other: Self) -> None:
        """A wrapper around list.extend."""
        self.extend(other)


class DictContext(dict, ContextMixin):
    """Wrapper around dict with some additional merge-related functionality."""

    def _get_identifier(self, item: Any, key: Optional[str]) -> str | int:
        """Get an identifier for an arbitrary object.

        This method controls how to handle objects inserted without a specified
        key.
        """
        if key is not None:
            return str(key)
        elif hasattr(item, "name"):
            return item.name
        elif hasattr(item, "__name__"):
            return item.__name__
        else:
            return id(item)

    def _insert_item(self, key, value):
        if key in self and isinstance(self[key], ContextMixin):
            self[key].join(value)
        else:
            self[key] = value

    def insert(self, item: Any, key: Optional[str] = None) -> None:
        """Recursively insert an item into existing subcontexts.

        If no key is passed, then a key is generated by examining, in order of
        preference,
          1. item.name, if it exists;
          2. item.__name__, if it exists;
          3. id(item).

        If self already contains the passed key and the associated value is an
        instance of ContextMixin, then the item to be inserted is passed to
        its ``join()`` method.  If not, then the item is inserted using the
        normal dict.__setitem__ method.
        """
        self._insert_item(self._get_identifier(item, key), item)

    def merge(self, other: Self) -> None:
        """Insert each item in other into self."""
        for k, v in other.items():
            self._insert_item(k, v)
